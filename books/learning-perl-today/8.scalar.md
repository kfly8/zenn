---
title: "スカラー型"
---

スカラーは単一の値を表し、文字列、数値など多態性を持ちます。実際、スカラーが取りうる状態を一覧に表すと次のように表現できます。
インデント構造は包含関係を表していて、例えば文字列は定義値の一種です。よくあるプログラミング言語と違って、数値が文字列に包含されていることが、Perlらしいところです。

```
# Perl Scalar:
Undef                   # 未定義値
Bool                    # 真偽値
Defined                 # 定義値
  Value (Non Reference) #   リファレンスではない値
      Str               #     文字列
          Num           #       数値
              Int       #         整数値
  Reference             #   リファレンス
      ScalarRef[`a]     #     スカラーリファレンス
      ArrayRef[`a]      #     配列リファレンス
      HashRef[`a]       #     ハッシュリファレンス
      CodeRef           #     コードリファレンス
      RegexpRef         #     正規表現リファレンス
      GlobRef           #     グロブリファレンス
      Object            #     オブジェクト
```

## 未定義値（Undef）

初期化されていない変数や、`undef`関数を明示的に利用した時、未定義値となります。

```perl
# いずれも未定義値
my $v1;
my $v2 = undef;
my $v3 = 'hello';
undef $v3;
```

`//`（定義済み論理和演算子）や`defined`関数を使って、値が定義済みかどうか判定できます。

```perl
my $v1 = $message // 'Hello'; # $v1は$messageが未定義の場合、'Hello'になる
my $v2 = defined $message ? $message : 'Hello'; # $v2は$messageが未定義の場合、'Hello'になる。上と同じ意味。
```

未定義値にありがちな警告やエラーは次の通りです。

```perl
# 定義値を期待している場面で、未定義値を利用すると次の警告がでます。

say $v;
# => Use of uninitialized value $v in say 

my @a = ('hoge', undef, 'piyo');
my $a = join ',', @a;
# => Use of uninitialized value $a[1] in join or string
```

```perl
# 未定義値からメソッド呼び出しすると、実行時エラーになります。

my $v;
$v->hello();
Can't call method "hello" on an undefined value
```

## 真偽値（Boolean）

組み込みユーティリティの[builtin](https://metacpan.org/pod/builtin)のtrue/falseや、`$a == 1`、`$a < $b`、`!$a` など等価演算、比較演算、論理演算などで、真偽値を得られます。
Perl 5.36までは、Perlには真偽値はないと説明されてきましたが、Perl 5.36以降、Perl内部で真偽値を区別できるようになりました。

```perl
if (true) { say "真" }
if (false) { say "偽" }

say is_bool($a == 1) ? '真偽値' : '真偽値ではない'; # 真偽値
say is_bool('hello') ? '真偽値' : '真偽値ではない'; # 真偽値ではない
```

ですが、真偽値に限らず、すべての値で真偽の評価ができ、以下の時、偽値(falsy)として評価されます。これ以外は、すべて真値(truthy)です。

- 未定義値 `undef`
- 数値の`0`および`0`と評価される数値表現
  - `0.0`、`0e2`、`0x0` など
- 文字列の空文字列`""`および`"0"`
- 空の配列、ハッシュ、リスト`()`

```perl
say undef ? 'truthy' : 'falsy'; # falsy
say 0     ? 'truthy' : 'falsy'; # falsy
say ""    ? 'truthy' : 'falsy'; # falsy
say 'foo' ? 'truthy' : 'falsy'; # truthy
```

[詳しい内容をwandboxで見る](https://wandbox.org/permlink/oWNOGnVZP5v8f3lh)

## 文字列（String）

文字列はダブルクォート`"`またはシングルクォート`'`で囲んで表現します。

```perl
my $name = "Perl";
my $message = 'Hello, World';

# ダブルクォート内では変数展開が行われる
say "My name is $name";  # My name is Perl

# シングルクォート内では変数展開されない
say 'My name is $name';  # My name is $name
```

文字列の連結は`.`演算子を使います。

```perl
my $first = "Hello";
my $second = "World";
my $combined = $first . ", " . $second;  # "Hello, World"
```

エスケープシーケンス：

```perl
my $tab = "Hello\tWorld";   # タブ
my $newline = "Line1\nLine2"; # 改行
my $quote = "He said \"Hi\""; # ダブルクォート
```

## 数値（Number）

Perlでは整数と浮動小数点数を区別せず、どちらも数値として扱います。

```perl
my $int = 42;
my $float = 3.14;
my $scientific = 1.23e-4;  # 0.000123
my $hex = 0xFF;             # 16進数: 255
my $oct = 0755;             # 8進数: 493
my $bin = 0b11111111;       # 2進数: 255
```

数値演算：

```perl
my $sum = 10 + 5;      # 15
my $diff = 10 - 5;     # 5
my $product = 10 * 5;  # 50
my $quotient = 10 / 5; # 2
my $power = 2 ** 8;    # 256
my $modulo = 10 % 3;   # 1
```

## 文字列と数値の自動変換

Perlの特徴の一つは、文字列と数値の自動変換です。文脈によって適切に変換されます。

```perl
my $str = "123";
my $num = $str + 0;     # 数値文脈: 123
my $concat = $num . ""; # 文字列文脈: "123"

# 文字列と数値の演算
say "10" + "20";        # 30 (数値として扱われる)
say 10 . 20;            # "1020" (文字列として扱われる)
```

数値として評価できない文字列を数値文脈で使うと警告が出ます：

```perl
my $result = "abc" + 1;
# Argument "abc" isn't numeric in addition (+)
# $result は 1 になる（"abc"は0として扱われる）
```

## リファレンス（Reference）

リファレンスは、他のデータへの参照（ポインタ）です。`\`演算子でリファレンスを作成します。

### スカラーリファレンス（ScalarRef）

```perl
my $value = 42;
my $ref = \$value;       # スカラーリファレンス
say $$ref;               # 42 (デリファレンス)

$$ref = 100;             # リファレンス経由で値を変更
say $value;              # 100
```

### 配列リファレンス（ArrayRef）

```perl
my @array = (1, 2, 3);
my $ref = \@array;       # 配列リファレンス

# 無名配列リファレンスの作成
my $anon_ref = [4, 5, 6];

# デリファレンス
say $ref->[0];           # 1
say $$anon_ref[1];       # 5
say @$ref;               # 123
```

### ハッシュリファレンス（HashRef）

```perl
my %hash = (name => "Perl", version => 5.42);
my $ref = \%hash;        # ハッシュリファレンス

# 無名ハッシュリファレンスの作成
my $anon_ref = { foo => "FOO", bar => "BAR" };

# デリファレンス
say $ref->{name};        # Perl
say $$anon_ref{foo};     # FOO
say %$ref;               # namePerlversion5.42
```

### コードリファレンス（CodeRef）

```perl
my $add = sub {
    my ($a, $b) = @_;
    return $a + $b;
};

say $add->(2, 3);        # 5

# 名前付きサブルーチンのリファレンス
sub greet { say "Hello!" }
my $ref = \&greet;
$ref->();                # Hello!
```

### 正規表現リファレンス（RegexpRef）

```perl
my $regex = qr/\d+/;     # 正規表現リファレンス

if ("abc123" =~ $regex) {
    say "数字が含まれています";
}

# 修飾子付き
my $case_insensitive = qr/perl/i;
say "Perl" =~ $case_insensitive;  # 1 (マッチする)
```

### グロブリファレンス（GlobRef）とファイルハンドル

グロブリファレンスは、シンボルテーブルのエントリへの参照です。ファイルハンドルの操作などで利用されます。

```perl
open my $fh, '<', 'file.txt' or die $!;
my $ref = \*$fh;         # グロブリファレンス

# より一般的にはファイルハンドルは直接スカラー変数に格納
open my $file, '<', 'data.txt' or die $!;
```

## リファレンスの判定

`ref`関数を使って、リファレンスの型を調べることができます。

```perl
use v5.42;

my $scalar_ref = \42;
my $array_ref = [1, 2, 3];
my $hash_ref = { a => 1 };
my $code_ref = sub { };
my $regex_ref = qr/./;

say ref $scalar_ref;     # SCALAR
say ref $array_ref;      # ARRAY
say ref $hash_ref;       # HASH
say ref $code_ref;       # CODE
say ref $regex_ref;      # Regexp
say ref "not a ref";     # (空文字列)
```

## SEE ALSO

- [perldoc.jp/perldata](https://perldoc.jp/docs/perl/5.42.0/perldata.pod)
- [perldoc.jp/perlref](https://perldoc.jp/docs/perl/5.42.0/perlref.pod)



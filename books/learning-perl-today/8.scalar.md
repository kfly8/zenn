---
title: "スカラー型"
---

スカラーは単一の値を表し、文字列、数値など多態性を持ちます。実際、スカラーが取りうる状態を一覧に表すと次のように表現できます。
インデント構造は包含関係を表していて、例えば文字列は定義値の一種です。よくあるプログラミング言語と違って、数値が文字列に包含されていることが、Perlらしいところです。

```
# Perl Scalar:
Undef                   # 未定義値
Bool                    # 真偽値
Defined                 # 定義値
  Value (Non Reference) #   リファレンスではない値
      Str               #     文字列
          Num           #       数値
              Int       #         整数値
  Reference             #   リファレンス
      ArrayRef          #     配列リファレンス
      HashRef           #     ハッシュリファレンス
      ScalarRef         #     スカラーリファレンス
      CodeRef           #     コードリファレンス
      RegexpRef         #     正規表現リファレンス
      GlobRef           #     グロブリファレンス
      Object            #     オブジェクト
```

## 未定義値（Undef）

初期化されていない変数や、`undef`関数を明示的に利用した時、未定義値となります。

```perl
# いずれも未定義値
my $v1;
my $v2 = undef;
my $v3 = 'hello';
undef $v3;
```

`//`（定義済み論理和演算子）や`defined`関数を使って、値が定義済みかどうか判定できます。

```perl
my $v1 = $message // 'Hello'; # $v1は$messageが未定義の場合、'Hello'になる
my $v2 = defined $message ? $message : 'Hello'; # $v2は$messageが未定義の場合、'Hello'になる。上と同じ意味。
```

未定義値にありがちな警告やエラーは次の通りです。

```perl
# 定義値を期待している場面で、未定義値を利用すると次の警告がでます。

say $v;
# => Use of uninitialized value $v in say 

my @a = ('hoge', undef, 'piyo');
my $a = join ',', @a;
# => Use of uninitialized value $a[1] in join or string
```

```perl
# 未定義値からメソッド呼び出しすると、実行時エラーになります。

my $v;
$v->hello();
Can't call method "hello" on an undefined value
```

## 真偽値（Boolean）

組み込みユーティリティの[builtin](https://metacpan.org/pod/builtin)のtrue/falseや、`$a == 1`、`$a < $b`、`!$a` など等価演算、比較演算、論理演算などで、真偽値を得られます。
Perl 5.36までは、Perlには真偽値はないと説明されてきましたが、Perl 5.36以降、Perl内部で真偽値を区別できるようになりました。

```perl
if (true) { say "真" }
if (false) { say "偽" }

say is_bool($a == 1) ? '真偽値' : '真偽値ではない'; # 真偽値
say is_bool('hello') ? '真偽値' : '真偽値ではない'; # 真偽値ではない
```

ですが、真偽値に限らず、すべての値で真偽の評価ができ、以下の時、偽値(falsy)として評価されます。これ以外は、すべて真値(truthy)です。

- 未定義値 `undef`
- 数値の`0`および`0`と評価される数値表現
  - `0.0`、`0e2`、`0x0` など
- 文字列の空文字列`""`および`"0"`
- 空の配列、空のハッシュ、空のリスト

```perl
say undef ? 'truthy' : 'falsy'; # falsy
say 0     ? 'truthy' : 'falsy'; # falsy
say ""    ? 'truthy' : 'falsy'; # falsy
say 1     ? 'truthy' : 'falsy'; # truthy
say 'foo' ? 'truthy' : 'falsy'; # truthy
```

[詳しい内容をwandboxで見る](https://wandbox.org/permlink/KGQPILEb2TER6zFu)

値が真偽の評価をされる場面、より正確には、値がスカラーコンテキストで真偽評価される場面は、if文 `if (xxx) { }`、三項演算子 `xxx ? 'a' :'b'`、while文 `while (xxx) { }` などです。スカラーコンテキストについてはFIXME章で解説します。

## 文字列（String）

シングルクォートされた文字列は、`'STRING'` または `q/STRING/` で書けます。`q//`はクォート演算子と呼ばれ、`q!!`、`q[]`のように状況に応じた区切り文字を選べます。
選択できる区切り文字の一覧は、こちらで確認できます。https://perldoc.jp/docs/perl/5.42.0/perlop.pod#List32of32Extra32Paired32Delimiters

ダブルクォートされた文字列は、`"STRING"` または `qq/STRING/` で書けます。`qq//`はダブルクォート演算子と呼ばれます。利用できる区切り文字は`q//`と同じです。
ダブルクォートされた場合、変数展開をしたり、改行(`\n`)などのエスケープシーケンスを利用できます。

```perl
my $s1 = 'Hello, World';
my $s2 = q/Hello World/;
my $s3 = "Hello World";
my $s4 = qq/Hello World/;

my $message = "世界";
print "Hello, $message\n"; # Hello, 世界
```

ヒアドキュメント(`<<EOS`)を利用すると、改行が書いた通りになるので便利です。Perl5.26から、`<<~EOS`のよう`~`(チルダ修飾子)をいれると、ヒアドキュメントをインデントでき、読みやすくなります。

```perl
sub find_by_id($db, $id) {
    my $sql = <<~SQL
        SELECT id, name,
        FROM item
        WHERE
            id = ?
    SQL

    $db->query($sql, $id);
} 
```

文字列の代表的な演算は次の通りです。

| 内容       | 演算子   | 例          | 詳細                                             |
| ------     | -------- | -----       | ------                                           |
| 等価比較   | eq       | `$x eq $y`  | $x と $y が文字列として等しいかどうか            |
| 不等価比較 | ne       | `$x ne $y`  | $x と $y が文字列として等しくないかどうか        |
| より小さい | lt       | `$x lt $y`  | $x が $y より文字列として小さいか (less than)    |
| 以下       | le       | `$x le $y`  | $x が $y 以下か (less than or equal)             |
| より大きい | gt       | `$x gt $y`  | $x が $y より文字列として大きいか (greater than) |
| 以上       | ge       | `$x ge $y`  | $x が $y 以上か (greater than or equal)          |
| 比較演算子 | cmp      | `$x cmp $y` | $x と $y を比較 (-1, 0, 1を返す)                 |
| 連結       | .        | `$x . $y`   | $x と $y を連結                                  |
| 繰り返し   | x        | `$x x 3`    | $x を3回繰り返す                                 |
| 長さ       | length   | `length $x` | 文字列の長さを返す                               |

文字列比較は辞書順で行われます：

```perl
say "apple" lt "banana";  # 1 (真: appleがbananaより辞書順で前)
say "10" lt "9";          # 1 (真: 文字列として"1"は"9"より前)
say "abc" cmp "def";      # -1 (abcはdefより前)
say "foo" cmp "foo";      # 0 (等しい)
say "xyz" cmp "abc";      # 1 (xyzはabcより後)
```

文字列のパターンマッチングと置換もできます。詳しくはFIXME章で行います。

```perl
# パターンマッチング
my $text = "Hello, Perl!";
if ($text =~ /Perl/) {
    say "Perlが見つかりました";
}

# 置換
my $str = "Hello, World!";
$str =~ s/World/Perl/;     # WorldをPerlに置換
say $str;                  # Hello, Perl!

# 変換
my $upper = "hello";
$upper =~ tr/a-z/A-Z/;     # 小文字を大文字に変換
say $upper;                # HELLO
```

## 数値（Number）

Perlの数値は、整数、浮動小数点、文字列の10進数の3つの方法で表現できます。

```perl
$n = 123;        # 10進数 / 整数
$n = 3.14;       # 10進数 / 浮動小数点
$n = 0xFF;       # 16進数: 255
$n = 0755;       # 8進数: 493
$n = 0b11111111; # 2進数: 255
$n = 1.23e-4;    # 指数表現: 0.000123 
$n = '123';      # 文字列として書かれた10進数: 123
$n = '1.23e-4';  # 文字列として書かれた10進数: 0.000123
$n = '0755';     # 文字列として書かれた10進数: 755 ※先頭の0は8進数を示していない
```

数値の代表的な演算は次の通りです。

| 内容       | 演算子   | 例          | 詳細                                    |
| ------     | -------- | -----       | ------                                  |
| 等価比較   | ==       | `$x == $y`  | $x と $y が数値として等しいかどうか     |
| 不等価比較 | !=       | `$x != $y`  | $x と $y が数値として等しくないかどうか |
| より小さい | <        | `$x < $y`   | $x が $y より数値として小さいか         |
| 以下       | <=       | `$x <= $y`  | $x が $y 以下か                         |
| より大きい | >        | `$x > $y`   | $x が $y より大きいか                   |
| 以上       | >=       | `$x >= $y`  | $x が $y 以上か                         |
| 比較演算子 | <=>      | `$x <=> $y` | $x と $y を比較 (-1, 0, 1を返す)        |
| 加算       | +        | `$x + $y`   | $x と $y を加算                         |
| 減算       | -        | `$x - $y`   | $x から $y を減算                       |
| 乗算       | *        | `$x * $y`   | $x と $y を乗算                         |
| 除算       | /        | `$x / $y`   | $x を $y で除算                         |
| 剰余       | %        | `$x % $y`   | $x を $y で割った余り                   |
| べき乗     | **       | `$x ** $y`  | $x の $y 乗                             |

Perlの特徴的な点として、文字列と数値の自動変換です。例えば、等価比較する際に、`$x eq $y` と書けば、スカラー`$x`、`$y`を文字列として評価して比較をし、`$x == $y`と書けば、スカラー`$x`、`$y`を数値として評価して比較をします。

これはスカラーの演算が、Perl内部で多重定義されていると考えても良いです。以下、疑似コードです。

```
# 等価比較 eq の定義
boolean eq(scalar s1, scalar s2);

boolean eq(string s1, string s2) {
  return s1 == s2
}

boolean eq(number n1, number n2) {
  s1 = to_string(n1)
  s2 = to_string(n2)
  return eq(s1,s2)
}

# 等価比較 == の定義
boolean ==(scalar s1, scalar s2);

boolean ==(string s1, string s2) {
  n1 = to_number(s1)
  n2 = to_number(s2)
  return ==(n1,n2)
}

boolean ==(number n1, number n2) {
  n1 == n2
}
```

10進数として評価できない文字列を、数値演算で使うと警告がでます。ただ十中八九意図した挙動ではないと思うため、`use warnings FATAL => 'numeric'` のようにwarningsプラグマを調整して、エラーとなるようにすることをおすすめします。

```perl
my $result = "123abc" + 1;
# => Argument "123abc" isn't numeric in addition (+)
# $result は 124 になる（"123abc"は123として扱われる）
```

## リファレンス（Reference）

1994年10月にPerl5がリリースされるまで、Perlで複雑なデータ構造を表現することは難しかったです。
例えば、リストの要素はスカラーで、配列やハッシュはリストの一種と前章で説明をしましたが、
次のコードのように `%user1`, `%user2`,`%user3`という3つのハッシュを、配列`@users`に書いても、
意図通り3つのユーザーをもった配列になりません。配列の要素はスカラーだからです。

```perl
my %user1 = (name => 'taro', age => 10);
my %user2 = (name => 'hana', age => 11);
my %user3 = (name => 'jiro', age => 7);

my @users = (%user1, %user2, %user3);
# => 3つのユーザーを持った配列ではない。
```

ここでC言語のポインターのアイデアを借用します。値そのものではなく値の参照を表現、言い方を変えれば、配列やハッシュの参照をスカラーとして表現できれば、複雑なデータ構造を表現できるのではないでしょうか？

```perl
my $user1 = pointer to %user1;
my $user2 = pointer to %user2;
my $user3 = pointer to %user3;
my @users = ( $user1, $user2, $user3 );
```

ですが、C言語のポインターままでは、メモリ管理が複雑で、Perlの手軽さを損なってしまいます。
そこで、Perl5では、参照カウント方式の自動ガベージコレクション付きのポインターを導入します。これがリファレンスです。

リファレンスによって、リストの要素はスカラーであるという原則を維持したまま、複雑なデータ構造を表現でき、それでいて、メモリ管理は自動になります。Perl5のリリースで、さらにリファレンスを応用するオブジェクト指向の機構も入り、テキスト処理言語から汎用言語へと変貌したリリースでした。

`\`演算子で値のリファレンスを作成できます。リファレンスは勿論スカラーです。また、リファレンスから元の値を取得することをデリファレンスと言います。

```perl
my $user1 = \%user1;
my $user2 = \%user2;
my $user3 = \%user3;
my @users = ( $user1, $user2, $user3 );
```

### 配列リファレンス（ArrayRef）

配列リファレンスの作成方法は、配列`@array`に`\`をつけるか、無名配列リファレンスのコンストラクタ`[]`を利用する2通りの方法があります。

```perl
my @fruits = ('apple', 'banana', 'cherry');
my $fruits = \@fruits;

# or
my $fruits = ['apple', 'banana', 'cherry'];
```

配列リファレンスの単一要素を参照する場合、アロー演算子`->`を利用します。

```perl
$fruits->[0]; # 'apple'  / 0番目を参照
$fruits->[1]; # 'banana' / 1番目を参照

$fruits->[0] = '杏'; # 0番目を杏に書き換え
```

配列リファレンスの複数要素を参照する場合、`->@`を利用します。これを後置デリファレンスの配列スライスと呼びます。

```perl
my @pick = $fruits->@[1,2]; # ('banana', 'cherry') / ($fruits->[1], $fruits->[2]) と一緒
my @all = $fruits->@*; # ('apple', 'banana', 'cherry') / 配列リファレンス全体をデリファレンス
```

配列リファレンスを利用することで、例えば、行列のような構造も作成できます。

```perl
my $matrix = [
  [1, 0, 0],
  [0, 1, 0],
  [0, 0, 1],
];
```

### ハッシュリファレンス（HashRef）

ハッシュリファレンスの作成方法は、ハッシュ`%hash`に`\`をつけるか、無名ハッシュリファレンスのコンストラクタ`{}`を利用する2通りの方法があります。

```perl
my %info = (name => 'Perl', released => 1987, influenced => ["C", "sed", "AWK"]);
my $info = \%info;

# or
my $info = { name => 'Perl', released => 1987, influenced => ["C", "sed", "AWK"] };
```

ハッシュリファレンスの値を一つ参照する場合、アロー演算子`->`を利用します。

```perl
$info->{name};     # 'Perl' / the 'name' value from $info
$info->{released}; # 1987   / the 'released' value from $info

$info->{influenced};     # ["C", "sed", "AWK"]
$info->{influenced}->[1] # 'sed' / 配列リファレンス`$info->{influenced}の1番目を参照
$info->{influenced}[1]   # 'sed' / 2つ目以降のアロー演算子は省略できる
```

ハッシュリファレンスの値を複数参照する場合、`->@`を利用します。

```perl
my @subinfo = $info->@{'name', 'released}; # ('Perl', 1987)
```

ハッシュリファレンスのキーと値の組を参照する場合、`->%`を利用します。これを後置デリファレンスのハッシュスライスと呼びます。

```perl
my %subinfo = $info->%{'name', 'released'}; # (name => 'Perl', released => 1987)
my %info = $info->%*; # (name => 'Perl', released => 1987, influenced => ["C", "sed", "AWK"] ) / ハッシュリファレンス全体をデリファレンス
```

こうして、配列とハッシュのリファレンスによって、複雑なデータ構造を表現できます。
上で説明した導入意義はこれで解決しますが、実際、Perlのリファレンスは配列、ハッシュ以外にもあります。
実はリファレンスは、Perlのオブジェクト指向プログラミングや関数型プログラミングの基礎にもなるため、このままリファレンスの説明を続けていきます。

### スカラーリファレンス（ScalarRef）

スカラーリファレンスの作成方法は、スカラーに`\`をつけて作成をします。

```perl
my $value = 42;
my $ref = \$value;

# or
my $ref = \42;
```

スカラーリファレンスのデリファレンスは、`$ref->$*`で行います。

```perl
$ref->$*; # 42
```

これで、Perlの3つのデータ型、スカラー、配列、ハッシュのリファレンスをすべて紹介しました。

### コードリファレンス（CodeRef）

関数の詳しい説明は、FIXME章で行います。
Perlでは関数をリファレンス化することで、（リファレンスはスカラーであるため、）配列やハッシュに含めたり、関数の引数や返り値として利用でき、関数を第一級オブジェクトとして扱うことができます。リファレンス化された関数をコードリファレンスと呼びます。

コードリファレンスの作成方法は、名前付き関数に`\&`をつけるか、無名関数`sub { }`を利用する2通りの方法があります。

```perl
sub double($x) { $x * 2 }
my $double = \&double;

# or
my $double = sub($x) { $x * 2 }
```

コードリファレンスの実行は、`->(...arguments)`を使います。

```perl
$double->(11); # 22

# リスト(1,2,3) の各要素を倍にしたリストを作成
my @doubled = map { $double->($_) } (1,2,3);
# => (2,4,6)
```

### 正規表現リファレンス（RegexpRef）

正規表現の詳しい説明は、FIXME章で行います。
正規表現をリファレンス化することで、（リファレンスはスカラーであるため、）コードリファレンスと同様に配列やハッシュに含めたり、関数の引数や返り値として利用でき、正規表現も第一級オブジェクトとして扱うことができます。

正規表現リファレンスは、`qr//`演算子で作成します。

```perl
my $regex = qr/P/;     # Pを含む文字列にマッチする正規表現のリファレンス

if ("Perl" =~ $regex) {
    say "Pが含まれています";
}

# リストを$regex にマッチする要素に絞り込みする
my @plang = grep { $_ =~ $regex } ('Perl', 'PHP', 'Python', 'Ruby', 'JavaScript');
# => ('Perl', 'PHP', 'Python')
```

### グロブリファレンス（GlobRef）

グロブリファレンスは、シンボルテーブルのエントリへの参照です。主にファイルハンドルの操作で利用されますが、現代のPerlではファイルハンドルは直接スカラー変数に格納する方が一般的です。

```perl
# 伝統的なグロブリファレンス
open my $fh, '<', 'file.txt' or die $!;
my $ref = \*$fh;         # グロブリファレンス

# 現代的な方法（推奨）
open my $file, '<', 'data.txt' or die $!;  # $fileは既にファイルハンドルのリファレンス

# グロブリファレンスの使用例
sub print_to_handle {
    my $handle_ref = shift;
    print $handle_ref "Hello, World!\n";
}

open my $output, '>', 'output.txt' or die $!;
print_to_handle($output);  # ファイルハンドルをそのまま渡せる
```

## リファレンスの判定

`ref`関数を使って、リファレンスの型を調べることができます。

```perl
use v5.42;

my $scalar_ref = \42;
my $array_ref = [1, 2, 3];
my $hash_ref = { a => 1 };
my $code_ref = sub { };
my $regex_ref = qr/./;

say ref $scalar_ref;     # SCALAR
say ref $array_ref;      # ARRAY
say ref $hash_ref;       # HASH
say ref $code_ref;       # CODE
say ref $regex_ref;      # Regexp
say ref "not a ref";     # (空文字列)
```

## SEE ALSO

- [perldoc.jp/perldata](https://perldoc.jp/docs/perl/5.42.0/perldata.pod)
- [perldoc.jp/perlop](https://perldoc.jp/docs/perl/5.42.0/perlop.pod)
- [perldoc.jp/perlref](https://perldoc.jp/docs/perl/5.42.0/perlref.pod)



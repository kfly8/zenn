---
title: "スカラー型"
---

スカラーは単一の値を表し、文字列、数値など多態性を持ちます。実際、スカラーが取りうる状態を一覧に表すと次のように表現できます。
インデント構造は包含関係を表していて、例えば文字列は定義値の一種です。よくあるプログラミング言語と違って、数値が文字列に包含されていることが、Perlらしいところです。

```
# Perl Scalar:
Undef                   # 未定義値
Bool                    # 真偽値
Defined                 # 定義値
  Value (Non Reference) #   リファレンスではない値
      Str               #     文字列
          Num           #       数値
              Int       #         整数値
  Reference             #   リファレンス
      ArrayRef[`a]      #     配列リファレンス
      HashRef[`a]       #     ハッシュリファレンス
      ScalarRef[`a]     #     スカラーリファレンス
      CodeRef           #     コードリファレンス
      RegexpRef         #     正規表現リファレンス
      GlobRef           #     グロブリファレンス
      Object            #     オブジェクト
```

## 未定義値（Undef）

初期化されていない変数や、`undef`関数を明示的に利用した時、未定義値となります。

```perl
# いずれも未定義値
my $v1;
my $v2 = undef;
my $v3 = 'hello';
undef $v3;
```

`//`（定義済み論理和演算子）や`defined`関数を使って、値が定義済みかどうか判定できます。

```perl
my $v1 = $message // 'Hello'; # $v1は$messageが未定義の場合、'Hello'になる
my $v2 = defined $message ? $message : 'Hello'; # $v2は$messageが未定義の場合、'Hello'になる。上と同じ意味。
```

未定義値にありがちな警告やエラーは次の通りです。

```perl
# 定義値を期待している場面で、未定義値を利用すると次の警告がでます。

say $v;
# => Use of uninitialized value $v in say 

my @a = ('hoge', undef, 'piyo');
my $a = join ',', @a;
# => Use of uninitialized value $a[1] in join or string
```

```perl
# 未定義値からメソッド呼び出しすると、実行時エラーになります。

my $v;
$v->hello();
Can't call method "hello" on an undefined value
```

## 真偽値（Boolean）

組み込みユーティリティの[builtin](https://metacpan.org/pod/builtin)のtrue/falseや、`$a == 1`、`$a < $b`、`!$a` など等価演算、比較演算、論理演算などで、真偽値を得られます。
Perl 5.36までは、Perlには真偽値はないと説明されてきましたが、Perl 5.36以降、Perl内部で真偽値を区別できるようになりました。

```perl
if (true) { say "真" }
if (false) { say "偽" }

say is_bool($a == 1) ? '真偽値' : '真偽値ではない'; # 真偽値
say is_bool('hello') ? '真偽値' : '真偽値ではない'; # 真偽値ではない
```

ですが、真偽値に限らず、すべての値で真偽の評価ができ、以下の時、偽値(falsy)として評価されます。これ以外は、すべて真値(truthy)です。

- 未定義値 `undef`
- 数値の`0`および`0`と評価される数値表現
  - `0.0`、`0e2`、`0x0` など
- 文字列の空文字列`""`および`"0"`
- 空の配列、空のハッシュ、空のリスト

```perl
say undef ? 'truthy' : 'falsy'; # falsy
say 0     ? 'truthy' : 'falsy'; # falsy
say ""    ? 'truthy' : 'falsy'; # falsy
say 1     ? 'truthy' : 'falsy'; # truthy
say 'foo' ? 'truthy' : 'falsy'; # truthy
```

[詳しい内容をwandboxで見る](https://wandbox.org/permlink/KGQPILEb2TER6zFu)

値が真偽の評価をされる場面、より正確には、値がスカラーコンテキストで真偽評価される場面は、if文 `if (xxx) { }`、三項演算子 `xxx ? 'a' :'b'`、while文 `while (xxx) { }` などです。スカラーコンテキストについてはFIXME章で解説します。

## 文字列（String）

シングルクォートされた文字列は、`'STRING'` または `q/STRING/` で書けます。`q//`はクォート演算子と呼ばれ、`q!!`、`q[]`のように状況に応じた区切り文字を選べます。
選択できる区切り文字の一覧は、こちらで確認できます。https://perldoc.jp/docs/perl/5.42.0/perlop.pod#List32of32Extra32Paired32Delimiters

ダブルクォートされた文字列は、`"STRING"` または `qq/STRING/` で書けます。`qq//`はダブルクォート演算子と呼ばれます。利用できる区切り文字は`q//`と同じです。
ダブルクォートされた場合、変数展開をしたり、改行(`\n`)などのエスケープシーケンスを利用できます。

```perl
my $s1 = 'Hello, World';
my $s2 = q/Hello World/;
my $s3 = "Hello World";
my $s4 = qq/Hello World/;

my $message = "世界";
print "Hello, $message\n"; # Hello, 世界
```

ヒアドキュメント(`<<EOS`)を利用すると、改行が書いた通りになるので便利です。Perl5.26から、`<<~EOS`のよう`~`(チルダ修飾子)をいれると、ヒアドキュメントをインデントでき、読みやすくなります。

```perl
sub find_by_id($db, $id) {
    my $sql = <<~SQL
        SELECT id, name,
        FROM item
        WHERE
            id = ?
    SQL

    $db->query($sql, $id);
} 
```

文字列の代表的な演算は次の通りです。

| 内容       | 演算子   | 例          | 詳細                                             |
| ------     | -------- | -----       | ------                                           |
| 等価比較   | eq       | `$x eq $y`  | $x と $y が文字列として等しいかどうか            |
| 不等価比較 | ne       | `$x ne $y`  | $x と $y が文字列として等しくないかどうか        |
| より小さい | lt       | `$x lt $y`  | $x が $y より文字列として小さいか (less than)    |
| 以下       | le       | `$x le $y`  | $x が $y 以下か (less than or equal)             |
| より大きい | gt       | `$x gt $y`  | $x が $y より文字列として大きいか (greater than) |
| 以上       | ge       | `$x ge $y`  | $x が $y 以上か (greater than or equal)          |
| 比較演算子 | cmp      | `$x cmp $y` | $x と $y を比較 (-1, 0, 1を返す)                 |
| 連結       | .        | `$x . $y`   | $x と $y を連結                                  |
| 繰り返し   | x        | `$x x 3`    | $x を3回繰り返す                                 |
| 長さ       | length   | `length $x` | 文字列の長さを返す                               |

文字列比較は辞書順で行われます：

```perl
say "apple" lt "banana";  # 1 (真: appleがbananaより辞書順で前)
say "10" lt "9";          # 1 (真: 文字列として"1"は"9"より前)
say "abc" cmp "def";      # -1 (abcはdefより前)
say "foo" cmp "foo";      # 0 (等しい)
say "xyz" cmp "abc";      # 1 (xyzはabcより後)
```

文字列のパターンマッチングと置換もできます。詳しくはFIXME章で行います。

```perl
# パターンマッチング
my $text = "Hello, Perl!";
if ($text =~ /Perl/) {
    say "Perlが見つかりました";
}

# 置換
my $str = "Hello, World!";
$str =~ s/World/Perl/;     # WorldをPerlに置換
say $str;                  # Hello, Perl!

# 変換
my $upper = "hello";
$upper =~ tr/a-z/A-Z/;     # 小文字を大文字に変換
say $upper;                # HELLO
```

## 数値（Number）

Perlの数値は、整数、浮動小数点、文字列の10進数の3つの方法で表現できます。

```perl
$n = 123;        # 10進数 / 整数
$n = 3.14;       # 10進数 / 浮動小数点
$n = 0xFF;       # 16進数: 255
$n = 0755;       # 8進数: 493
$n = 0b11111111; # 2進数: 255
$n = 1.23e-4;    # 指数表現: 0.000123 
$n = '123';      # 文字列として書かれた10進数: 123
$n = '1.23e-4';  # 文字列として書かれた10進数: 0.000123
$n = '0755';     # 文字列として書かれた10進数: 755 ※先頭の0は8進数を示していない
```

数値の代表的な演算は次の通りです。

| 内容       | 演算子   | 例          | 詳細                                    |
| ------     | -------- | -----       | ------                                  |
| 等価比較   | ==       | `$x == $y`  | $x と $y が数値として等しいかどうか     |
| 不等価比較 | !=       | `$x != $y`  | $x と $y が数値として等しくないかどうか |
| より小さい | <        | `$x < $y`   | $x が $y より数値として小さいか         |
| 以下       | <=       | `$x <= $y`  | $x が $y 以下か                         |
| より大きい | >        | `$x > $y`   | $x が $y より大きいか                   |
| 以上       | >=       | `$x >= $y`  | $x が $y 以上か                         |
| 比較演算子 | <=>      | `$x <=> $y` | $x と $y を比較 (-1, 0, 1を返す)        |
| 加算       | +        | `$x + $y`   | $x と $y を加算                         |
| 減算       | -        | `$x - $y`   | $x から $y を減算                       |
| 乗算       | *        | `$x * $y`   | $x と $y を乗算                         |
| 除算       | /        | `$x / $y`   | $x を $y で除算                         |
| 剰余       | %        | `$x % $y`   | $x を $y で割った余り                   |
| べき乗     | **       | `$x ** $y`  | $x の $y 乗                             |

Perlの特徴的な点として、文字列と数値の自動変換です。例えば、等価比較する際に、`$x eq $y` と書けば、スカラー`$x`、`$y`を文字列として評価して比較をし、`$x == $y`と書けば、スカラー`$x`、`$y`を数値として評価して比較をします。

これはスカラーの演算が、Perl内部で多重定義されていると考えても良いです。以下、疑似コードです。

```
# 等価比較 eq の定義
boolean eq(scalar s1, scalar s2);

boolean eq(string s1, string s2) {
  return s1 == s2
}

boolean eq(number n1, number n2) {
  s1 = to_string(n1)
  s2 = to_string(n2)
  return eq(s1,s2)
}

# 等価比較 == の定義
boolean ==(scalar s1, scalar s2);

boolean ==(string s1, string s2) {
  n1 = to_number(s1)
  n2 = to_number(s2)
  return ==(n1,n2)
}

boolean ==(number n1, number n2) {
  n1 == n2
}
```

10進数として評価できない文字列を、数値演算で使うと警告がでます。ただ十中八九意図した挙動ではないと思うため、`use warnings FATAL => 'numeric'` のようにwarningsプラグマを調整して、エラーとなるようにすることをおすすめします。

```perl
my $result = "123abc" + 1;
# => Argument "123abc" isn't numeric in addition (+)
# $result は 124 になる（"123abc"は123として扱われる）
```

## リファレンス（Reference）

1994年10月にPerl5がリリースされるまで、Perlで複雑なデータ構造を表現することは難しかったです。
例えば、リストの要素はスカラーで、配列やハッシュはリストの一種と前章で説明をしましたが、
次のコードのように `%user1`, `%user2`,`%user3`という3つのハッシュを、配列`@users`に書いても、
意図通り3つのユーザーをもった配列になりません。配列の要素はスカラーだからです。

```perl
my %user1 = (name => 'taro', age => 10);
my %user2 = (name => 'hana', age => 11);
my %user3 = (name => 'jiro', age => 7);

my @users = (%user1, %user2, %user3);
# => 3つのユーザーを持った配列ではない。
```

ここでC言語のポインターのアイデアを借用します。値そのものではなく値の参照を表現、言い方を変えれば、配列やハッシュの参照をスカラーとして表現できれば、複雑なデータ構造を表現できるのではないでしょうか？

```perl
my $user1 = pointer to %user1;
my $user2 = pointer to %user2;
my $user3 = pointer to %user3;
my @users = ( $user1, $user2, $user3 );
```

ですが、C言語のポインターままでは、メモリ管理が複雑で、Perlの手軽さを損なってしまいます。
そこで、Perlでは、参照カウント方式の自動ガベージコレクション付きのポインターを導入します。これがリファレンスです。

リファレンスによって、リストの要素はスカラーであるという原則を維持したまま、複雑なデータ構造を表現でき、それでいて、メモリ管理は自動になります。Perl5のリリースで、さらにリファレンスを応用するオブジェクト指向の機構も入り、テキスト処理言語から汎用言語へと変貌したリリースでした。

`\`演算子で値のリファレンスを作成します。リファレンスは勿論スカラーです。

```
my $user1 = \%user1;
my $user2 = \%user2;
my $user3 = \%user3;
my @users = ( $user1, $user2, $user3 );
```


### スカラーリファレンス（ScalarRef）

```perl
my $value = 42;
my $ref = \$value;       # スカラーリファレンス
say $$ref;               # 42 (デリファレンス)

$$ref = 100;             # リファレンス経由で値を変更
say $value;              # 100
```

### 配列リファレンス（ArrayRef）

```perl
my @array = (1, 2, 3);
my $ref = \@array;       # 配列リファレンス

# 無名配列リファレンスの作成
my $anon_ref = [4, 5, 6];

# デリファレンス
say $ref->[0];           # 1
say $$anon_ref[1];       # 5
say @$ref;               # 123
```

### ハッシュリファレンス（HashRef）

```perl
my %hash = (name => "Perl", version => 5.42);
my $ref = \%hash;        # ハッシュリファレンス

# 無名ハッシュリファレンスの作成
my $anon_ref = { foo => "FOO", bar => "BAR" };

# デリファレンス
say $ref->{name};        # Perl
say $$anon_ref{foo};     # FOO
say %$ref;               # namePerlversion5.42
```

### コードリファレンス（CodeRef）

```perl
my $add = sub {
    my ($a, $b) = @_;
    return $a + $b;
};

say $add->(2, 3);        # 5

# 名前付きサブルーチンのリファレンス
sub greet { say "Hello!" }
my $ref = \&greet;
$ref->();                # Hello!
```

### 正規表現リファレンス（RegexpRef）

```perl
my $regex = qr/\d+/;     # 正規表現リファレンス

if ("abc123" =~ $regex) {
    say "数字が含まれています";
}

# 修飾子付き
my $case_insensitive = qr/perl/i;
say "Perl" =~ $case_insensitive;  # 1 (マッチする)
```

### グロブリファレンス（GlobRef）とファイルハンドル

グロブリファレンスは、シンボルテーブルのエントリへの参照です。ファイルハンドルの操作などで利用されます。

```perl
open my $fh, '<', 'file.txt' or die $!;
my $ref = \*$fh;         # グロブリファレンス

# より一般的にはファイルハンドルは直接スカラー変数に格納
open my $file, '<', 'data.txt' or die $!;
```

## リファレンスの判定

`ref`関数を使って、リファレンスの型を調べることができます。

```perl
use v5.42;

my $scalar_ref = \42;
my $array_ref = [1, 2, 3];
my $hash_ref = { a => 1 };
my $code_ref = sub { };
my $regex_ref = qr/./;

say ref $scalar_ref;     # SCALAR
say ref $array_ref;      # ARRAY
say ref $hash_ref;       # HASH
say ref $code_ref;       # CODE
say ref $regex_ref;      # Regexp
say ref "not a ref";     # (空文字列)
```

## SEE ALSO

- [perldoc.jp/perldata](https://perldoc.jp/docs/perl/5.42.0/perldata.pod)
- [perldoc.jp/perlop](https://perldoc.jp/docs/perl/5.42.0/perlop.pod)
- [perldoc.jp/perlref](https://perldoc.jp/docs/perl/5.42.0/perlref.pod)



---
title: "スコープ"
---

Perlにおけるスコープは、変数やプラグマの有効範囲を決定する重要な概念です。特にプラグマをスコープ単位で制御できるのは、Perlならではの強力な機能です。

## レキシカルスコープ（my変数）

`my`で宣言された変数は、レキシカルスコープを持ちます。これは最も一般的なスコープで、変数が宣言されたブロック内でのみ有効です。

```perl
{
    my $x = 10;
    {
        my $x = 20;  # 内側のスコープで新しい$xを定義
        say $x;      # 20
    }
    say $x;          # 10（外側の$xは影響を受けない）
}
# say $x;          # エラー: $xはスコープ外
```

サブルーチンの引数も`my`でレキシカルスコープになります：

```perl
sub calculate($x, $y) {  # $xと$yはサブルーチン内のレキシカル変数
    my $result = $x + $y;
    return $result;
}
# $x, $y, $resultはここでは参照できない
```

## パッケージ変数とour

`our`で宣言された変数は、パッケージ変数を作成（または既存のパッケージ変数への参照）し、同時にレキシカルスコープでのエイリアスを作成します。重要な点は、`our`はどこで宣言されても、そのパッケージの変数を作成することです。

```perl
package MyApp;

{
    our $DEBUG = 1;    # パッケージ変数 $MyApp::DEBUG を作成
    say $DEBUG;        # 1（エイリアスとしてアクセス）
}

# say $DEBUG;        # エラー: ourのレキシカルなエイリアスはスコープ外
say $MyApp::DEBUG;   # 1（パッケージ変数自体は存在する）

# 別の場所でourを使うと、同じパッケージ変数への新しいエイリアスを作成
our $DEBUG;
say $DEBUG;          # 1（既存の$MyApp::DEBUGへのエイリアス）
```

## 動的スコープ（local）

`local`は動的スコープを提供し、パッケージ変数、特殊変数、さらにシンボルテーブルのエントリを一時的に変更できます。変更は関数の呼び出しチェーン全体で有効です。

### パッケージ変数の一時的な変更

```perl
our $config = "production";

sub log_message {
    say "Config: $config";
}

sub test_mode {
    local $config = "testing";  # 動的スコープで一時的に変更
    log_message();               # "Config: testing"
}

test_mode();
say "After: $config";           # "After: production"（元に戻る）
```

### 特殊変数の一時的な変更

特殊変数（`$/`、`$_`、`$!`など）は真のグローバル変数で、`local`で一時的に変更するのが一般的です：

```perl
# ファイル全体を一度に読み込む
sub slurp_file {
    my ($filename) = @_;
    open my $fh, '<', $filename or die $!;
    local $/ = undef;       # 入力レコードセパレータを一時的に無効化
    return <$fh>;
}

# デフォルトの変数を一時的に変更
sub process_array {
    my @data = @_;
    local $_ = "default";
    for (@data) {
        # ループ内で$_は各要素になる
        say $_;
    }
    # ループ後も$_は"default"のまま
}
```

### シンボルテーブルの一時的な変更

`local`を使って関数やtypeglob全体を一時的に置き換えることができます：

```perl
# 関数の一時的なモック化（テストでよく使われる）
sub original_func { "original" }

{
    local *original_func = sub { "mocked" };
    say original_func();  # "mocked"

    # この中で呼ばれる関数も影響を受ける
    sub caller_func { original_func() }
    say caller_func();    # "mocked"
}

say original_func();      # "original"（元に戻る）

# STDERRの一時的なリダイレクト
{
    local *STDERR;
    open(STDERR, '>', '/dev/null') or die $!;
    warn "This warning is discarded";
}
# STDERRは元の状態に戻る
warn "This warning is shown";
```

## state変数（静的変数）

`state`で宣言された変数は、レキシカルスコープを持ちながら、値がサブルーチンの呼び出し間で保持されます。

```perl
use feature 'state';  # または use v5.10 以降

sub counter {
    state $count = 0;  # 初回のみ初期化
    return ++$count;
}

say counter();  # 1
say counter();  # 2
say counter();  # 3
```

## プラグマのレキシカルスコープ

Perlの最も強力な機能の一つが、プラグマをレキシカルスコープで制御できることです。プラグマの効果は、それが宣言されたブロック内でのみ有効です。

### strictプラグマ

```perl
# デフォルトでstrictは無効（古いコードの場合）
$undefined_var = 10;  # エラーにならない

{
    use strict;
    # $another_var = 20;  # エラー: 宣言されていない変数
    my $another_var = 20;  # OK
}

$yet_another = 30;  # strictの効果はブロック外では無効
```

### warningsプラグマ

```perl
{
    use warnings;
    my $x;
    print $x;  # 警告: Use of uninitialized value
}

{
    no warnings 'uninitialized';  # 特定の警告カテゴリを無効化
    my $y;
    print $y;  # 警告なし
}
```

### featureプラグマ

```perl
{
    use feature 'say';
    say "Hello";  # sayが使える
}

{
    use feature ':5.36';  # Perl 5.36の全機能を有効化
    say "World";          # say
    my $ref = {};
    $ref->%*;            # 後置デリファレンス
}
```

### experimentalプラグマ

```perl
{
    use experimental 'signatures';
    sub add($x, $y) {  # シグネチャが使える
        return $x + $y;
    }
}

# sub multiply($x, $y) { ... }  # エラー: スコープ外ではシグネチャは使えない
```

## カスタムプラグマの作成

独自のレキシカルプラグマを作成することも可能です：

```perl
package MyPragma;
use strict;
use warnings;

sub import {
    my $caller = caller;
    # インポート時の処理
    $^H{mypraga_enabled} = 1;  # ヒントハッシュに情報を保存
}

sub unimport {
    # no MyPragma時の処理
    delete $^H{mypraga_enabled};
}

1;
```

使用例：

```perl
{
    use MyPragma;
    # MyPragmaの効果がある
}
# ここではMyPragmaの効果はない
```

## スコープガード

スコープを抜ける際に必ず実行される処理を定義できます：

```perl
use Guard;

sub process_file($filename) {
    open my $fh, '<', $filename or die $!;

    my $guard = guard {
        close $fh;
        say "File closed";
    };

    # ファイル処理
    # ...

    # return、die、正常終了のいずれでも$guardのコードが実行される
}
```

## スコープのベストプラクティス

1. **変数は最小限のスコープで宣言**
   ```perl
   # 良い例
   for my $i (0..10) {
       # $iはループ内でのみ有効
   }

   # 避けるべき例
   my $i;
   for $i (0..10) {
       # $iがループ外でも残る
   }
   ```

2. **プラグマは必要最小限のスコープで有効化**
   ```perl
   sub risky_operation {
       no warnings 'redefine';  # この警告のみ、この関数内のみで無効化
       # ...
   }
   ```

3. **パッケージ変数や特殊変数の変更にはlocal を使用**
   ```perl
   sub slurp_file($filename) {
       open my $fh, '<', $filename or die $!;
       local $/;  # 特殊変数を一時的にundef化
       return <$fh>;
   }
   ```

## SEE ALSO

- [perlsub - Perlのサブルーチン](https://perldoc.jp/docs/perl/perlsub.pod)
- [perlmod - Perlのモジュール](https://perldoc.jp/docs/perl/perlmod.pod)
- [perlpragma - Perlプラグマの作成方法](https://perldoc.jp/docs/perl/perlpragma.pod)
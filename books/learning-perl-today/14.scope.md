---
title: "スコープ"
---

Perlにおけるスコープは、変数やプラグマの有効範囲を指す概念です。

## my

`my`で宣言された変数は、変数が宣言されたブロック内でのみ有効なレキシカルスコープを持ちます。ブロックは、波括弧`{}`で囲むことでつくることができます。

```perl
{ # ブロック1
    my $x = 10; # ブロック1で有効な変数を定義

    { # ブロック2
        my $x = 20;  # ブロック2で新しい$xを定義
        say $x;      # 20
    }
    say $x;          # 10（ブロック1の$xはブロック2の影響を受けない）
}
# say $x;          # エラー: $xはスコープ外
```

関数の引数やif文でもレキシカルスコープになります。

```perl
sub add($x, $y) {  # $xと$yはサブルーチン内のレキシカル変数
    return $x + $y;
}
# $x, $yはここでは参照できない

if (my @match = $str =~ /(\d+)/g) {
    say @match;
}
# @matchはここでは参照できない
```

レキシカル関数を定義する時も`my`を利用します。通常の関数の場合、同一パッケージに同名の関数を複数個定義できませんが、レキシカル関数の場合、スコープが異なれば同名で問題ありません。

```perl
use Test2::V0;

subtest 'add' => sub {
    my sub subject($x, $y) { My::Foo::Bar::Baz::add($x, $y) }

    is subject(1,2), 3;
    is subject(4,5), 9;
};

subtest 'double' => sub {
    my sub subject($x, $y) { My::Foo::Bar::Baz::double($x) }

    is subject(3), 6;
    is subject(9), 18;
};
```

## state

`state`で宣言された変数は、`my`と同じレキシカルスコープを持ちながら、変数が初期化済みであれば再初期化をせず値は保持されます。

```perl
use v5.42;

sub counter {
    state $count = 0;  # 初回のみ初期化
    return ++$count;
}

say counter();  # 1
say counter();  # 2
say counter();  # 3
```

## our

`our`で宣言された変数は、パッケージ変数を作成します。このパッケージ変数は、パッケージ名を完全修飾することでコードのどこからでも参照できます。

```perl
package My::App::Foo {
    our $VERSION = 0.11;
}

say $My::App::Foo::VERSION; # 0.11
```

## local

`local`は、パッケージ変数、関数などシンボルテーブルのエントリーや、特殊変数を一時的に変更する役割を持ちます。デバッグやテストなどで光る機能です。

次の例は、`SomeScript`パッケージのパッケージ変数`$DEBUG`を一時的に有効にしています。

```perl
package SomeScript {
    our $DEBUG = "0";

    sub run {
        $DEBUG && warn "START TO RUN";
        # do something
        $DEBUG && warn "END TO RUN";
    }
}

local $SomeScript::DEBUG = 1;
SomeScript::run();
```

関数の一時的なモックにも使えます。

```perl
use v5.42;
use utf8;

package My::App {
  sub hello { "HELLO" }
}

my sub send_message {
    my $message = My::App::hello();
    say "Send $message"
};

{
    # このブロック中だけhelloは一時的に上書きされる
    local *My::App::hello = sub { "mocked" };
    send_message(); # "Send mocked"
}

send_message(); # "Send Hello" # 元に戻っている
```

Perlにはグローバルに定義された特殊変数があります。例えば、最後に補足された例外を保持する[$@](https://perldoc.jp/variable/%24%40)や入力レコードの区切り文字を保持する[$/](https://perldoc.jp/variable/%24%2F)などです。こういったグローバル変数も`local`で一時的に上書きできます。

例えば、次のコードはファイル全体を一度に読み込むコードです。どちらのコードも目的を達成できますが、`local`を利用した方が簡潔に書けています。

```perl
# 通常、入力レコードの区切り文字は改行区切りのため、ファイル全体を読み込みする場合、一行ずつ取得し連結する
sub slurp_file($filename) {
    open my $fh, '<', $filename or die $!;
    my $data = '';
    while (my $line = <$fh>) {
        $data .= $line;
    }
    return $data;
}

# 入力レコードの区切り文字を無効にすることで、ファイル全体を読み込みすることができる。
sub slurp_file($filename) {
    open my $fh, '<', $filename or die $!;
    local $/;
    return <$fh>; 入力のレコードの区切り文字が無効になっているため、全ての行を一度に取得することができる
}
```

---

ここからスコープに関連した事例を書きます。

## ガードオブジェクト

Perlでは、オブジェクトのリファレンスカウントが0になりオブジェクト破棄されるタイミングに行う処理をDESTROYという特別なメソッドに登録できます。このDESTROYメソッドにリソース解放、モックを戻すなどの後処理を登録し、スコープを抜けた際に後処理を実行するオブジェクトを、Perlではガードオブジェクトと呼びます。

例えば、`Test2::V0` のmock関数は、ガードオブジェクトの`$mock`が有効な時だけ関数の上書きを行います。

```perl
use v5.42;
use Test2::V0;

package WeatherAPI {
    sub get_temperature($city) {
        # 実際には外部APIを叩いて気温を返す
        die "Network error: cannot connect to weather API";
    }
}

sub format_weather($city) {
    sprintf("現在の$cityの気温は%s度です", WeatherAPI::get_temperature($city))
}

package WeatherAPITest {
    my $mock = mock 'WeatherAPI' => (
        override => [
            get_temperature => sub($city) {
                return 25 if $city eq 'Tokyo';
                return 15 if $city eq 'London';
                return 30;
            }
        ]
    );

    is format_weather('Tokyo'), '現在のTokyoの気温は25度です';
    is format_weather('London'), '現在のLondonの気温は15度です';
}
```

他には、`DBIx::QueryLog`は、ガードオブジェクトが有効な時だけプロファイリングできます。

```perl
use v5.42;
use DBIx::QueryLog ();

sub run_heavy_process() {

    {
        # このスコープでだけプロファイリングされる
        my $guard = DBIx::QueryLog->enable;
        # do something
    }
    # do something
}
```

## defer

上記のガードオブジェクトを利用する場合、ガードオブジェクトをレキシカル変数を用意する必要があり、やや不格好です。
また、スコープを抜けてもどこかにリファレンスの参照が残っていて、DESTROYが呼ばれないこともありえます。

こういった心配を減らすべく、v5.36から`defer`ブロックが追加されました。
`defer BLOCK`と書くことで、スコープを抜けた際、ブロックの処理が実行されます。

```perl
use v5.42;
use experimental qw(defer);

{
  say "Hello Block1";
  defer { say "Bye Block1" }

  {
    say "Hello Block2";
    defer { say "Bye Block2" }
  }
}
# =>
# Hello Block1
# Hello Block2
# Bye Block2
# Bye Block1
```

## `strict`プラグマの制限を一時的に緩める

`use v5.42`あるいは`use strict`と書くとPerlの記述を厳格にできますが、一時的にそういった制限を緩めることができます。CPANモジュールなどのライブラリを読んだり、書いたりする場面で特に現れます。例えば、次のコードはモジュールの呼び出し元に関数を生やしています。

```perl
use v5.42;
package My::Hello {
    sub import {
        my $caller = caller; # 呼び出し元のパッケージを取得

        no strict 'refs'; # このimportの呼び出し中だけ、シンボリックリファレンスの利用を許可する
        *{$caller . '::hello'} = sub { say 'HELLO' }; # 呼び出し元に、hello関数を生やす
    }
}

# My::Helloをimportしたパッケージに、hello関数が生える
use My::Hello;
hello();
```

## SEE ALSO

- [perlsub - Perlのサブルーチン](https://perldoc.jp/docs/perl/perlsub.pod)
- [perlmod - Perlのモジュール](https://perldoc.jp/docs/perl/perlmod.pod)
- [perlpragma - Perlプラグマの作成方法](https://perldoc.jp/docs/perl/perlpragma.pod)

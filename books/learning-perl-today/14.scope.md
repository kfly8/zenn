---
title: "スコープ"
---

Perlにおけるスコープは、変数やプラグマの有効範囲を指す概念です。

## my（レキシカルスコープ）

`my`で宣言された変数は、変数が宣言されたブロック内でのみ有効なレキシカルスコープを持ちます。ブロックは、波括弧`{}`で囲むことでつくることができます。

```perl
{ # ブロック1
    my $x = 10; # ブロック1で有効な変数を定義

    { # ブロック2
        my $x = 20;  # ブロック2で新しい$xを定義
        say $x;      # 20
    }
    say $x;          # 10（ブロック1の$xはブロック2の影響を受けない）
}
# say $x;          # エラー: $xはスコープ外
```

関数の引数やif文でもレキシカルスコープになります。

```perl
sub add($x, $y) {  # $xと$yはサブルーチン内のレキシカル変数
    return $x + $y;
}
# $x, $yはここでは参照できない

if (my @match = $str =~ /(\d+)/g) {
    say @match;
}
# @matchはここでは参照できない
```

レキシカル関数を定義する時も`my`を利用します。通常の関数の場合、同一パッケージに同名の関数を複数個定義できませんが、レキシカル関数の場合、スコープが異なれば同名で問題ありません。

```perl
use Test2::V0;

subtest 'add' => sub {
    my sub subject($x, $y) { My::Foo::Bar::Baz::add($x, $y) }

    is subject(1,2), 3;
    is subject(4,5), 9;
};

subtest 'double' => sub {
    my sub subject($x, $y) { My::Foo::Bar::Baz::double($x) }

    is subject(3), 6;
    is subject(9), 18;
};
```

## state

`state`で宣言された変数は、`my`と同じレキシカルスコープを持ちながら、変数が初期化済みであれば再初期化をせず値は保持されます。

```perl
use v5.42;

sub counter {
    state $count = 0;  # 初回のみ初期化
    return ++$count;
}

say counter();  # 1
say counter();  # 2
say counter();  # 3
```

## our

`our`で宣言された変数は、パッケージ変数を作成します。このパッケージ変数は、パッケージ名を完全修飾することでコードのどこからでも参照できます。

```perl
package My::App::Foo {
    our $VERSION = 0.11;
}

say $My::App::Foo::VERSION; # 0.11
```

## local

`local`は、パッケージ変数、関数などシンボルテーブルのエントリーや、特殊変数を一時的に変更する役割を持ちます。デバッグやテストなどで光る機能です。

次の例は、`SomeScript`パッケージのパッケージ変数`$DEBUG`を一時的に有効にしています。

```perl
package SomeScript {
    our $DEBUG = "0";

    sub run {
        $DEBUG && warn "START TO RUN";
        # do something
        $DEBUG && warn "END TO RUN";
    }
}

local $SomeScript::DEBUG = 1;
SomeScript->run();
```

関数の一時的なモックにも使えます。

```perl
use v5.42;
use utf8;

package My::App {
  sub hello { "HELLO" }
}

my sub send_message {
    my $message = My::App::hello();
    say "Send $message"
};

{
    # このブロック中だけhelloは一時的に上書きされる
    local *My::App::hello = sub { "mocked" };
    send_message(); # "Send mocked"
}

send_message(); # "Send Hello" # 元に戻っている
```

Perlにはグローバルに定義された特殊変数があります。例えば、最後に補足された例外を保持する[$@](https://perldoc.jp/variable/%24%40)や入力レコードの区切り文字を保持する[$/](https://perldoc.jp/variable/%24%2F)などです。こういったグローバル変数も`local`で一時的に上書きできます。

例えば、次のコードはファイル全体を一度に読み込むコードです。どちらのコードも目的を達成できますが、`local`を利用した方が簡潔に書けています。

```perl
# 通常、入力レコードの区切り文字は改行区切りのため、ファイル全体を読み込みする場合、一行ずつ取得し連結する
sub slurp_file($filename) {
    open my $fh, '<', $filename or die $!;
    my $data = '';
    while (my $line = <$fh>) {
        $data .= $line;
    }
    return $data;
}

# 入力レコードの区切り文字を無効にすることで、ファイル全体を読み込みすることができる。
sub slurp_file($filename) {
    open my $fh, '<', $filename or die $!;
    local $/;
    return <$fh>; 入力のレコードの区切り文字が無効になっているため、全ての行を一度に取得することができる
}
```

## プラグマのレキシカルスコープ

Perlの最も強力な機能の一つが、プラグマをレキシカルスコープで制御できることです。プラグマの効果は、それが宣言されたブロック内でのみ有効です。

### strictプラグマ

```perl
# デフォルトでstrictは無効（古いコードの場合）
$undefined_var = 10;  # エラーにならない

{
    use strict;
    # $another_var = 20;  # エラー: 宣言されていない変数
    my $another_var = 20;  # OK
}

$yet_another = 30;  # strictの効果はブロック外では無効
```

### warningsプラグマ

```perl
{
    use warnings;
    my $x;
    print $x;  # 警告: Use of uninitialized value
}

{
    no warnings 'uninitialized';  # 特定の警告カテゴリを無効化
    my $y;
    print $y;  # 警告なし
}
```

### featureプラグマ

```perl
{
    use feature 'say';
    say "Hello";  # sayが使える
}

{
    use feature ':5.36';  # Perl 5.36の全機能を有効化
    say "World";          # say
    my $ref = {};
    $ref->%*;            # 後置デリファレンス
}
```

### experimentalプラグマ

```perl
{
    use experimental 'signatures';
    sub add($x, $y) {  # シグネチャが使える
        return $x + $y;
    }
}

# sub multiply($x, $y) { ... }  # エラー: スコープ外ではシグネチャは使えない
```

## カスタムプラグマの作成

独自のレキシカルプラグマを作成することも可能です：

```perl
package MyPragma;
use strict;
use warnings;

sub import {
    my $caller = caller;
    # インポート時の処理
    $^H{mypraga_enabled} = 1;  # ヒントハッシュに情報を保存
}

sub unimport {
    # no MyPragma時の処理
    delete $^H{mypraga_enabled};
}

1;
```

使用例：

```perl
{
    use MyPragma;
    # MyPragmaの効果がある
}
# ここではMyPragmaの効果はない
```

## スコープガード

スコープを抜ける際に必ず実行される処理を定義できます：

```perl
use Guard;

sub process_file($filename) {
    open my $fh, '<', $filename or die $!;

    my $guard = guard {
        close $fh;
        say "File closed";
    };

    # ファイル処理
    # ...

    # return、die、正常終了のいずれでも$guardのコードが実行される
}
```

## スコープのベストプラクティス

1. **変数は最小限のスコープで宣言**
   ```perl
   # 良い例
   for my $i (0..10) {
       # $iはループ内でのみ有効
   }

   # 避けるべき例
   my $i;
   for $i (0..10) {
       # $iがループ外でも残る
   }
   ```

2. **プラグマは必要最小限のスコープで有効化**
   ```perl
   sub risky_operation {
       no warnings 'redefine';  # この警告のみ、この関数内のみで無効化
       # ...
   }
   ```

3. **パッケージ変数や特殊変数の変更にはlocal を使用**
   ```perl
   sub slurp_file($filename) {
       open my $fh, '<', $filename or die $!;
       local $/;  # 特殊変数を一時的にundef化
       return <$fh>;
   }
   ```

## SEE ALSO

- [perlsub - Perlのサブルーチン](https://perldoc.jp/docs/perl/perlsub.pod)
- [perlmod - Perlのモジュール](https://perldoc.jp/docs/perl/perlmod.pod)
- [perlpragma - Perlプラグマの作成方法](https://perldoc.jp/docs/perl/perlpragma.pod)

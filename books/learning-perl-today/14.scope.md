---
title: "スコープ"
---

Perlにおけるスコープは、変数やプラグマの有効範囲を決定する重要な概念です。特にプラグマをスコープ単位で制御できるのは、Perlならではの強力な機能です。

## レキシカルスコープ（my変数）

`my`で宣言された変数は、レキシカルスコープを持ちます。これは最も一般的なスコープで、変数が宣言されたブロック内でのみ有効です。

```perl
{
    my $x = 10;
    {
        my $x = 20;  # 内側のスコープで新しい$xを定義
        say $x;      # 20
    }
    say $x;          # 10（外側の$xは影響を受けない）
}
# say $x;          # エラー: $xはスコープ外
```

サブルーチンの引数も`my`でレキシカルスコープになります：

```perl
sub calculate($x, $y) {  # $xと$yはサブルーチン内のレキシカル変数
    my $result = $x + $y;
    return $result;
}
# $x, $y, $resultはここでは参照できない
```

## パッケージスコープ（our変数）

`our`で宣言された変数は、パッケージ変数へのレキシカルなエイリアスを作成します。パッケージ変数自体はグローバルですが、`our`宣言はレキシカルスコープを持ちます。

```perl
package MyApp;

our $VERSION = '1.0';  # パッケージ変数 $MyApp::VERSION のエイリアス

{
    our $DEBUG = 1;    # このブロック内でのみ $DEBUG として参照可能
    say $DEBUG;        # 1
}

# say $DEBUG;        # エラー: ourのエイリアスはスコープ外
say $MyApp::DEBUG;   # 1（完全修飾名なら参照可能）
```

## 動的スコープ（local）

`local`は動的スコープを提供し、グローバル変数やパッケージ変数の値を一時的に変更します。関数の呼び出しチェーン全体で効果があります。

```perl
our $global = "original";

sub show_value {
    say "In show_value: $global";
}

sub change_temporarily {
    local $global = "temporary";  # 動的スコープで一時的に変更
    show_value();                  # "In show_value: temporary"
}

change_temporarily();
say "After: $global";              # "After: original"（元に戻る）
```

特殊変数を一時的に変更する際によく使われます：

```perl
{
    local $/ = undef;       # 入力レコードセパレータを一時的に無効化
    my $content = <$fh>;    # ファイル全体を一度に読み込む
}
# $/は元の値に戻る
```

## state変数（静的変数）

`state`で宣言された変数は、レキシカルスコープを持ちながら、値がサブルーチンの呼び出し間で保持されます。

```perl
use feature 'state';  # または use v5.10 以降

sub counter {
    state $count = 0;  # 初回のみ初期化
    return ++$count;
}

say counter();  # 1
say counter();  # 2
say counter();  # 3
```

## プラグマのレキシカルスコープ

Perlの最も強力な機能の一つが、プラグマをレキシカルスコープで制御できることです。プラグマの効果は、それが宣言されたブロック内でのみ有効です。

### strictプラグマ

```perl
# デフォルトでstrictは無効（古いコードの場合）
$undefined_var = 10;  # エラーにならない

{
    use strict;
    # $another_var = 20;  # エラー: 宣言されていない変数
    my $another_var = 20;  # OK
}

$yet_another = 30;  # strictの効果はブロック外では無効
```

### warningsプラグマ

```perl
{
    use warnings;
    my $x;
    print $x;  # 警告: Use of uninitialized value
}

{
    no warnings 'uninitialized';  # 特定の警告カテゴリを無効化
    my $y;
    print $y;  # 警告なし
}
```

### featureプラグマ

```perl
{
    use feature 'say';
    say "Hello";  # sayが使える
}

{
    use feature ':5.36';  # Perl 5.36の全機能を有効化
    say "World";          # say
    my $ref = {};
    $ref->%*;            # 後置デリファレンス
}
```

### experimentalプラグマ

```perl
{
    use experimental 'signatures';
    sub add($x, $y) {  # シグネチャが使える
        return $x + $y;
    }
}

# sub multiply($x, $y) { ... }  # エラー: スコープ外ではシグネチャは使えない
```

## カスタムプラグマの作成

独自のレキシカルプラグマを作成することも可能です：

```perl
package MyPragma;
use strict;
use warnings;

sub import {
    my $caller = caller;
    # インポート時の処理
    $^H{mypraga_enabled} = 1;  # ヒントハッシュに情報を保存
}

sub unimport {
    # no MyPragma時の処理
    delete $^H{mypraga_enabled};
}

1;
```

使用例：

```perl
{
    use MyPragma;
    # MyPragmaの効果がある
}
# ここではMyPragmaの効果はない
```

## スコープガード

スコープを抜ける際に必ず実行される処理を定義できます：

```perl
use Guard;

sub process_file($filename) {
    open my $fh, '<', $filename or die $!;

    my $guard = guard {
        close $fh;
        say "File closed";
    };

    # ファイル処理
    # ...

    # return、die、正常終了のいずれでも$guardのコードが実行される
}
```

## スコープのベストプラクティス

1. **変数は最小限のスコープで宣言**
   ```perl
   # 良い例
   for my $i (0..10) {
       # $iはループ内でのみ有効
   }

   # 避けるべき例
   my $i;
   for $i (0..10) {
       # $iがループ外でも残る
   }
   ```

2. **プラグマは必要最小限のスコープで有効化**
   ```perl
   sub risky_operation {
       no warnings 'redefine';  # この警告のみ、この関数内のみで無効化
       # ...
   }
   ```

3. **グローバル変数の変更にはlocal を使用**
   ```perl
   sub slurp_file($filename) {
       open my $fh, '<', $filename or die $!;
       local $/;  # 一時的に変更
       return <$fh>;
   }
   ```

## SEE ALSO

- [perlsub - Perlのサブルーチン](https://perldoc.jp/docs/perl/perlsub.pod)
- [perlmod - Perlのモジュール](https://perldoc.jp/docs/perl/perlmod.pod)
- [perlpragma - Perlプラグマの作成方法](https://perldoc.jp/docs/perl/perlpragma.pod)
---
title: "パッケージ"
---

Perlのプログラムは、パッケージ（package）で分割できます。例えば、このコードでは、Foo::Barパッケージにて、List::Utilパッケージのshuffle関数をインポートしています。

```perl
package Foo::Bar;
use v5.42;
use List::Util qw(shuffle);

sub omikuji {
    my @shuffled = shuffle('大吉', '吉', '凶');
    return $shuffled[0];
}

package main;

# Foo::Barパッケージのomikuji関数を呼び出し
Foo::Bar::omikuji()
```

もしpackage を省略した場合、mainパッケージとみなされます。

```perl
use v5.42;

say __PACKAGE__; # => このプログラムのパッケージ名は、main
```

慣習として、パッケージ名とファイルパスは一致させる慣習があります。例えば、Foo::BarパッケージはFoo/Bar.pmに書きます。

```shell
└── lib
    ├── Foo
    │   └── Bar.pm # Foo::Bar パッケージ
    └── Foo.pm     # Fooパッケージ
```

一つのパッケージを複数のパッケージに分割して書くことはできませんが、一つのファイルに複数のパッケージを書くことはできます。例えば、内部的な処理を別パッケージに分けて、その内部パッケージは読み込みできないようにするパターンがあります。例えば、[Plack::Utilのinline_object](https://metacpan.org/dist/Plack/source/lib/Plack/Util.pm#L346)はこのパターンを利用しています。

```perl:Foo.pm
use v5.42;

package Foo {
    sub hello {
        my $message = Foo::Inner::message();
        return $message;
    }
}

package Foo::Inner {
    sub message { "Hello World from Inner package!" }
}
```

```perl:hello.pl
use v5.42;

use Foo;
say Foo::Bar::hello(); # Hello from Foo::Bar!

# use Foo::Inner をしても読み込めない。Foo/Inner.pm を読み込もうとするため。
```

こういった挙動を理解する為に、以下のパッケージ読み込みの簡易な擬似コードが参考になるはずです。より詳細な擬似コードは[require](https://perldoc.jp/func/require)を参照してください。

```perl
sub pseudo_require {
    my ($package) = @_;

    # Foo::Bar を Foo/Bar.pm に置換
    my $filename = $package =~ s!::!/!r;
    $filename .= '.pm';

    # 既に読み込み済みなら何もしない
    return if exists $INC{$filename} && $INC{$filename};

    # 該当のパッケージを 配列 @INC に格納されている
    for my $prefix (@INC) {
        my $fullpath = "${prefix}/${filename}"

        # 利用できないなら次の探索へ
        next if ! -e $fullpath || -d _ || -b _;

        # %INC 読み込み済みにする
        $INC{$filename} = $fullpath;

        # 読み込み実行
        my $result = do($fullpath);

        if (!$result) {
            # 読み込みエラー
        }

        return $result;
    }

    # 該当のパッケージが見つからなければ、エラー
    croak "Can't locate $filename in \@INC ...";
}
```

これが理解できると、perlの`-I`オプションは理解しやすいでしょう。例えば、次のようなファイル構成だった場合、hello.pl から lib/Foo.pm （Fooパッケージ）を読み込みたい場合、`perl -Ilib hello.pl` のようにすることで、`@INC`に`./lib`を追加して、`./lib`配下のファイルを探索するようになります。

```shell
% tree .
.
├── hello.pl
└── lib
    └── Foo.pm

% perl hello.pl
# => Can't locate Foo.pm in @INC

% perl -Ilib foo.pl
# => OK
```

余談となりますが、以前のperlでは、パッケージの末尾に`1;`のように真となる値を書く必要がありました。これは、上記の疑似コードの通り、ファイル読み込み結果（doの結果）を真にする必要があったからです。ですが、v5.38以降は、[module_true feature](https://metacpan.org/pod/feature#The-%27module_true%27-feature)によって、不要になりました。


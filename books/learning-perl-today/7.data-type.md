---
title: "データ型"
---

Perlのデータは、単一の値を表す**スカラー**とスカラーを要素にもつ**リスト**の2種に区分され、
さらに、リストは順序付きの**配列**、またはキーと値の組を持つ**ハッシュ**として扱えます。
つまり、Perlのデータ型は、スカラー、配列、ハッシュの3種だけです。

最も重要なデータ型はスカラーです。スカラーがリストの構成要素であることも理由の一つですが、
次章のリファレンスを理解すると、Perlのコードはほとんどスカラーで書けるからです。

## スカラー

スカラーは、内部的には、文字列、数値、リファレンスなどの状態を持つ構造体で、多態（ポリモーフィズム）を持っています。
スカラー変数は、名前に`$`をつけて、英語の`the`のように単一の値を表す目印になっています。

```perl
my $name = "Perl";        # 文字列 
my $age  = 30;            # 数値
my $less = $age < 40;     # 真偽値
my $u    = undef;         # 未定義値

# リファレンス（次章で詳述）
my $dice  = [1,2,3,4,5,6];                             # 配列リファレンス
my $dict  = { apple => 'りんご', banana => 'バナナ' }; # ハッシュリファレンス
my $code  = sub { print "Hello, World!\n" };           # コードリファレンス
my $regex = qr/\d+/;                                   # 正規表現リファレンス

my $ver = $DateTime::VERSION; # DateTimeパッケージの$VERSION変数 / the VERSION variable in the DateTime package
```

## リスト

リストは、スカラーをカンマ区切りで書き、丸括弧`()`で囲みます。

```perl
("apple", "banana");
(1,2,3,4,5);
("name", "Perl", "released", 1987, "influenced", ["C", "sed", "AWK"]);
```

カンマの代わりに`=>` を使うと、左辺が自動的にクォートされて便利です。`=>` はファットカンマと呼ばれます。

```perl
(name => "Perl", released => 1987, influenced => ["C", "sed", "AWK"]);
```

## 配列

配列は、リストを順序つきで扱うためのデータ型です。
配列変数は、名前に`@`をつけて、英語の`these`のように複数の値を表す目印になっています。

```perl
my @fruits  = ('apple', 'banana', 'cherry');
my @numbers = (1,2,3,4,5);
my @info    = (name => "Perl", released => 1987, influenced => ["C", "sed", "AWK"]);
```

配列の単一要素を参照する場合、`$`を利用します。

```perl
my $first = $fruits[0];  # 'apple'  / the first element of @fruits
my $third = $fruits[2];  # 'cherry' / the third element of @fruits
my $last  = $fruits[-1]; # 'cherry' / the last element of @fruits 負のインデックスで、配列の後ろからアクセスする

my $k1 = $info[0]; # 'name';
my $v1 = $info[1]; # 'Perl'
```

配列の複数要素を参照する場合、`@`を利用します。これを配列スライスと言います。

```perl
my @pick = @fruits[1,2]; # ('banana', 'cherry') / ($fruits[1],$fruits[2]) と一緒
my @kv1  = @info[0,1];   # ('name', 'Perl')
```

分割代入することもできます。

```perl
my ($one, $two, @rest) = (1,2,3,4,5);
$one # 1
$two # 2
@rest # (3,4,5)

my ($one, undef, @rest) = (1,2,3,4,5); # 不要な要素はundefで捨てれます
$one # 1
@rest # (3,4,5)
```

## ハッシュ

ハッシュは、リストをキーと値の組で扱うためのデータ型です。
ハッシュ変数は、名前に`%`をつけます。配列とは異なり、順序はランダムです。
リストの要素数が偶数でなければ、警告がでます。

```perl
my %info = (name => 'Perl', released => 1987, influenced => ["C", "sed", "AWK"]);
```

ハッシュの値を一つ参照する場合、`$`を利用します。

```perl
my $name       = $info{name};       # 'Perl' / the 'name' value from %info
my $released   = $info{released};   # 1987 / the 'released' value from %info
my $influenced = $info{influenced}; # ["C", "sed", "AWK"] / the 'influenced' value from %info
```

ハッシュの値を複数参照する場合、`@`を利用します。

```perl
my @info = @info{'name','released'}; # ('Perl', 1987)
```

ハッシュのキーと値の組を参照する場合、`%`を利用します。これをハッシュスライスと言います。

```perl
my %subinfo = %info{'name', 'released'}; # (name => 'Perl', released => 1987)
```

分割代入することもできます。

```perl
my ($message, %rest) = ('Hello', foo => 'FOO', bar => 'BAR');
$message # 'Hello'
%rest # (foo => 'FOO', bar => 'BAR')
```

## 配列とハッシュはリスト

Perlの配列とハッシュは、どちらもリストです。そのため、次のように相互変換して利用することができます。

```perl
my @array = ('name', 'Alice', 'age', 25);

# 配列をハッシュに代入
my %hash = @array;
$hash{name} # 'Alice'
$hash{age}  # 25

# ハッシュを配列に代入も可。ただし順序は不定
my @other = %hash;
# @other は ('name', 'Alice', 'age', 25) または ('age', 25, 'name', 'Alice') 
```

コマンド引数処理は良い実例です。

```shell
% some-command foo bar --verbose 1
```

```perl
#!/usr/bin/env perl
use v5.42;

my ($item1, $item2, %options) = @ARGV;  # コマンド引数は配列@ARGV に入っている
$item1                # 'foo'
$item2                # 'bar'
$options{'--verbose'} # 1
```

蛇足ですが、実際にコマンド引数処理で複雑なことをしたい場合は、[Getopt::Long::Descriptive](https://metacpan.org/pod/Getopt::Long::Descriptive)といったCPANモジュールを利用すると良いでしょう。

## SEE ALSO

- [perldoc.jp/perldata](https://perldoc.jp/docs/perl/5.42.0/perldata.pod)

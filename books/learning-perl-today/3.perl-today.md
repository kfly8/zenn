---
title: "Perlの今"
---

### Perlの変化

2022年、Perl v5.36のリリース以降、Perl本体の開発がこれまでにないほど活発です。組み込みのclass構文など言語機能の拡張が増えています。また、初学者を惑わす機能を予防する仕組みも導入され、プログラミング言語の現代的なプラクティスを取り入れる進化をしています。本書ではこの変化をできるだけお伝えしたいと思います。

TODO: 画像にする、見た目がスッキリするだけじゃなくて、カプセル化が良くなったりする / _cacheにアクセスできる、

#### BEFORE

```perl
package Cache::LRU;
use strict;
use warnings;

use Hash::Ordered;

sub new {
    my ($class, %args) = @_;
    my $self = {
        max_size => $args{max_size} // 20,
        _cache   => Hash::Ordered->new(),
    };
    return bless $self, $class;
}

sub set {
    my ($self, $key, $value) = @_;
    if ($self->{_cache}->exists($key)) {
        $self->{_cache}->delete($key);
    } elsif ($self->{_cache}->keys >= $self->{max_size}) {
        $self->{_cache}->shift;
    }
    $self->{_cache}->set($key, $value);
}

sub get {
    my ($self, $key) = @_;
    $self->{_cache}->get($key);
}

1;

my $cache = Cache::LRU->new(max_size => 3);

use feature qw(say);
$cache->set('a', 2);

say $cache->get('a'); # 1
```

#### AFTER

```perl
use v5.42;
use experimental qw(class);

use Hash::Ordered;

class Cache::LRU {
    field $max_size :param = 20;
    field $cache = Hash::Ordered->new();

    method set($key, $value) {
        if ($cache->exists($key)) {
            $cache->delete($key);
        } elsif ($cache->keys >= $max_size) {
            $cache->shift;
        }
        $cache->set($key, $value);
    }

    method get($key) {
        $cache->get($key);
    }
}

my $cache = Cache::LRU->new(max_size => 3);

$cache->set(a => 2);
say $cache->get('a'); # 2
```

この変化の背景の一つは、Perlの文法拡張をPerl本体を変更せずとも可能になっていることが挙げられます。具体的には、PEVANS氏らによって、2010年(v5.12)、コンパイルフェーズにASTを書き換えるkeyword pluginが導入され、Perlのモジュールで新機能の検証を行い、その後、Perl本体ん取り込まれるという流れが確立されました。
例えば、組み込みのclass構文は、[Corinna](https://github.com/Perl-Apollo/Corinna)でOvid氏によってデザインされ、PEVANS氏によって[Object::Pad](https://metacpan.org/pod/Object::Pad)で実装、検証され、その後、Perl本体に取り込まれました。

PEVANS氏は、London Perl Workshop 2016にて、こう語ったそうです。

> Perlをもっとよくしていくには、公開されている機能をギリギリまで使い倒して、できる人たちに「そんな無茶なやり方よりもっといい方法がある」と言わせるといい
> -- https://charsbar.hatenadiary.org/entry/20161217/1481954722 より引用

### ガラクタ出力機と生成AI

ラリー・ウォール氏は敬虔なクリスチャンだった為、Perlの名前は当初、新約聖書の「高価な真珠」にちなんで「Pearl」と名付けられていました。ですが、リリースする前に、同名のプログラミング言語があることに気づき、「Perl」と改名されたそうです。こういった名前の付け方のため、Perlの頭文字に元々意味があったわけではなく、ラリー・ウォール氏の言葉遊びで、「**P**ractical **E**xtraction and **R**eport **L**anguage（実用データレポート作成言語」という意味を込められました。さらに、同時に「**P**athologically **E**clectic **R**ubbish **L**ister（病的折衷主義のガラクタ出力機）」という皮肉的な意味も込められているそうです。実際、テキストファイルをパーズして集計するような使い捨てのワンライナーやスクリプトの山が筆者のローカルディレクトリには溜まっています。最近は、そんなガラクタ作りが、生成AIのおかげで捗ります。

```shell
prompt: 英文中の単語と「P e r l」と距離の近い順に出力するワンライナーをPerlで書いて。距離は、単語中の文字の出現頻度だけでとりあえずOK。

output:
perl -ne 'BEGIN{@p=split//,"Perl";for(@p){$pc{lc$_}++}}for$w(split/\W+/){%c=();for(split//,$w){$c{lc$_}++}$d=0;for$k(keys%c,keys%pc){$d+=abs(($c{$k}//0)-($pc{$k}//0))}$h{$w}=$d}END{print"$_: $h{$_}\n"for sort{$h{$a}<=>$h{$b}}keys%h}'
```

もちろん、このワンライナーは読めなくて問題ないです。
